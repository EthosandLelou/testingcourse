\documentclass{beamer}
\usetheme{default}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{hyperref}
\usepackage{listings}
\title{Software Testing  Lecture 7 \\ Property Based Testing}
\author{Justin Pearson}
\date{2017}
\setbeamertemplate{footline}[page number]
\setbeamertemplate{navigation symbols}{}

%Lecture 4 stuff
\newcommand{\todo}[1]{{\tt ... #1 ... }}
\newcommand{\Reach}{\mathrm{Reach}}
\newcommand{\Path}{\mathrm{path}}

%Lecture 5 stuff
\newcommand{\predset}{{\cal P}}
\newcommand{\clauseset}{{\cal C}}
%Stolen from Stackexchange
%http://tex.stackexchange.com/questions/20609/strikeout-in-math-mode 
\newcommand\hcancel[2][red]{\setbox0=\hbox{$#2$}%
\rlap{\raisebox{.45\ht0}{\textcolor{#1}{\rule{\wd0}{1pt}}}}#2} 

\begin{document}
\lstset{language=Python}

\begin{frame}
  \maketitle
\end{frame}

\begin{frame}[fragile]
  \frametitle{When are the enough unit tests?}
  Lets look at a really simple example.
  \begin{lstlisting}
import unittest

def add(x,y):
    return x+y

class TestAddition(unittest.TestCase):
    def test_add_1(self):
        self.assertEqual(add(3,4),7)

      \end{lstlisting}
We could go on writing a lot of test cases. You can try to find edge cases and
you could try to get some structural coverage of the code. 
\end{frame}
\begin{frame}[fragile]
  \frametitle{Random testing of addition}
  \begin{lstlisting}
def test_add_random_single():
    x = randint(-sys.maxsize,sys.maxsize)
    y = randint(-sys.maxsize,sys.maxsize)
    assert(add(x,y) == x+y)

def test_add_random(max_iterations):
    i = 0;
    while(i<max_iterations):
        test_add_random_single()
        i += 1
        sys.stdout.write('.')
    print("\nRan ",max_iterations," tests.")
  \end{lstlisting}
\end{frame}
\begin{frame}
  \frametitle{Random testing of addition}
  \begin{itemize}
  \item We should next expect any of our tests for addition to
    fail. Especially since we implement addition with addition.
  \item But it does illustrate some important concepts.
    \begin{itemize}
    \item Test oracles: A mechanism for determining if a test has passed or
      not.
    \item Test generator: A mechanism for generating test cases. 
      
    \end{itemize}
  \item Some thought has to go into both oracles and generators. For
    generators you have to decide what sort of coverage you going to give.
  \end{itemize}
  
\end{frame}
\begin{frame}[fragile]
  \frametitle{Set intersection}

The details are not important.  I built a
package\footnote{\url{https://bitbucket.org/justinkennethpearson/mdd}} for
representing sets of integers compactly as trees. Operations such as
intersection were provided.

Write inefficient but correct code:
\begin{lstlisting}
  def intersection(l1,l2):
    new_list = []
    for i in l1:
        if member(i,l2):
            new_list.append(i)
    return(new_list)
\end{lstlisting}

This is not a very efficient way doing set intersection, but we can use it as
an oracle together with randomly generated sets to generate lots of test
cases. 
\end{frame}

\begin{frame}
  \frametitle{Writing Test Oracles}
  It is   the same problem as always, given some inputs how do we know what
  the correct output is. Often you use testing as a way to think about the
  problem and try understand what the output will be for given inputs.

  If you have lots of randomly generated tests then this is obviously
  not practical.  There are a number of techniques available. 
  \begin{itemize}
  \item Specification based verification of the outputs.
  \item Redundant computations
  \item Consistency checks.
  \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{Specification based Verification}
  If you are lucky, then your software has a specification. If you less lucky,
 while trying to test the software and in dialogue with the programmer you
 write a specification.

 Given your specification there are a number of options.
  \begin{itemize}
  \item Use property based testing to derive test cases. More on this later.
  \item Use techniques from formal methods such as model checking,
    specification animation tools to generate test cases. This is often much
    easier than using formal methods to verify the software.
  \item Treat the specification as a combinatorial problem and use techniques
    such as constraint programming, SAT or SMT to model your problem and
    derive test cases (Take 1DL448).
  \item Write code the implements the specification and generates test cases.
  \end{itemize}
Techniques such as these are often referred to as model based testing.
\end{frame}
\begin{frame}
  \frametitle{Redundant Computations}
  We have already seen two examples earlier. There are a number of options.
  \begin{itemize}
  \item  Write inefficient but correct code, and  use this as an oracle. Very
    similar to model based testing, but often more simple. Never underestimate
    the power of a random number generator and redundant computations; it can
    be a very good way of finding bugs in code.
  \item Parallel development of code. Very expensive only used in domains with
    high reliability requirements (aerospace). Has its own
    problems. Psychology tells us that people make the same sort of errors.      
  \end{itemize}

\end{frame}
\begin{frame}
  \frametitle{Consistency Checks}
  % TODO -
\end{frame}
\begin{frame}
  \frametitle{Model Based Testing}
  %TODO
\end{frame}
\begin{frame}
  \frametitle{Property Based Testing}
  %TODO
\end{frame}
% Ideas - Never underestimate the power of a random number generator.
% Examples, addition , something more complicated (my set intersection tool).


%% More ideas -
%% Stuff from the book formal methods /specification for oracles , don't
%% forget constraint programming.
%%% Model based testing.
\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
